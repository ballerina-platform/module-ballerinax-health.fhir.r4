// Copyright (c) 2024, WSO2 LLC. (http://www.wso2.com).

// WSO2 LLC. licenses this file to you under the Apache License,
// Version 2.0 (the "License"); you may not use this file except
// in compliance with the License.
// You may obtain a copy of the License at

// http://www.apache.org/licenses/LICENSE-2.0

// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

// AUTO-GENERATED FILE.
// This file is auto-generated by Ballerina.

import ballerina/http;
import ballerina/lang.regexp;
import ballerinax/health.fhir.r4;
import ballerinax/health.fhir.r4.parser;
import ballerinax/health.fhir.r4.validator;
import ballerina/log;

# This method will validate the context data attached in the Cds request against it's respective Cds service definition.
#
# + cdsRequest - Cds request payload  
# + cdsService - Cds hook/ service definition
# + return - return CdsError, if there are any context validation issues 
public isolated function validateContext(CdsRequest cdsRequest, CdsService cdsService) returns CdsError? {

    Hook hook = <Hook>cdsRequest.hook;
    log:printInfo("Validating context for hook: " + hook);
    Context context = cdsRequest.context;
    string errorMessage = string `Context validation failed: ${hook}`;
    string description = string `Context should only contains set of data allowed by the specification: https://cds-hooks.hl7.org/hooks/${hook}/STU1/${hook}/#context`;

    // Default case: Unkown hook
    Context|error parsedOutput = createCdsError(string `Unkown hook: ${hook}`, 400);

    match hook {
        PATIENT_VIEW => {
            log:printInfo("Executing patient view hook");
            parsedOutput = context.cloneWithType(PatientViewContext);
        }

        ORDER_SIGN => {
            log:printInfo("Executing order sign hook");
            parsedOutput = context.cloneWithType(OrderSignContext);
        }

        ORDER_SELECT => {
            log:printInfo("Executing order select hook");
            parsedOutput = context.cloneWithType(OrderSelectContext);
        }

        ORDER_DISPATCH => {
            log:printInfo("Executing order dispatch hook");
            parsedOutput = context.cloneWithType(OrderDispatchContext);
        }

        ENCOUNTER_START => {
            log:printInfo("Executing encounter start hook");
            parsedOutput = context.cloneWithType(EncounterStartContext);
        }

        ENCOUNTER_DISCHARGE => {
            log:printInfo("Executing encounter discharge hook");
            parsedOutput = context.cloneWithType(EncounterDischargeContext);
        }

        _ => {
            log:printError("Unknown hook: " + hook);
            return <CdsError>parsedOutput;
        }
    }

    if ((parsedOutput is error)) {
        return createCdsError(errorMessage, 400, description = description);
    }
    return;
}

# Validate and fetch missing prefetch FHIR data for a CdsRequest.
#
# + cdsRequest - Cds request payload  
# + cdsService - Cds hook/ service definition
# + return - return CdsError, if there are any issues while processing the prefetch templates, 
# otherwise CdsRequest payload with newly fetched FHIR data
public isolated function validateAndProcessPrefetch(CdsRequest cdsRequest, CdsService cdsService) returns CdsRequest|CdsError {
    map<string> prefetchTemplates = {};
    map<r4:DomainResource> prefetchData = {};
    CdsRequest request = cdsRequest.clone();

    // If the CDS service has no prefetch templates defined, then no need to validate the request
    if cdsService.prefetch is map<string> {
        prefetchTemplates = <map<string>>cdsService.prefetch;
        if (prefetchTemplates.keys().length() < 1) {
            return request;
        }
    } else {
        return request;
    }

    if (request.prefetch is map<r4:DomainResource>) {
        prefetchData = <map<r4:DomainResource>>request.prefetch;
    }

    // If there are no any prefetch data in the request, or
    // required prefetch template keys are not matching with keys in the request prefetch data 
    //then following should we given in the request to fetch the required FHIR data
    string[] templateKeys = prefetchTemplates.keys().sort();
    string[] dataKeys = prefetchData.keys().sort();
    if (templateKeys != dataKeys || templateKeys.count() > dataKeys.count()) {
        // 1. Fhir server url
        if (request.fhirServer !is string) {
            return createCdsError("Can not find fhirServer url in the request", 400);
        }

        // 2. FhirAuthorization object contains access token, scopes etc
        if request.fhirAuthorization !is () && request.fhirAuthorization !is FhirAuthorization {
            return createCdsError("Can not find fhirAuthorization in the request", 400);
        }

        // Fetch missing prefetch FHIR data
        foreach string templateId in prefetchTemplates.keys() {
            if (!prefetchData.hasKey(templateId)) {
                request = check fetchFhirResource(cdsService.id, templateId, prefetchTemplates.get(templateId), request);
            } else {
                r4:FHIRValidationError? validated = validator:validate(prefetchData.get(templateId));
                if validated is r4:FHIRValidationError {
                    return createCdsError(string `FHIR data provided for prefetch ${templateId} in the request is not valid`, 412, cause = validated);
                }
            }
        }
    } else {
        foreach var key in prefetchData.keys() {
            r4:FHIRValidationError? validated = validator:validate(prefetchData.get(key));
            if validated is r4:FHIRValidationError {
                return createCdsError(string `FHIR data provided for the prefetch: ${key}`, 400, cause = validated);
            }
        }
    }

    return request;
}

isolated function fetchFhirResource(string hookId, string prefetchTemplateKey, string prefetchTemplate, CdsRequest cdsRequest) returns CdsError|CdsRequest {

    string template = prefetchTemplate.clone();
    lock {
        // Check wether the global prefetchTemplateAndContextPropertyMap contains an entry for the given hookId 
        if (!prefetchTemplateAndContextPropertyMap.hasKey(hookId)) {
            return cdsRequest.clone();
        }

        map<string> contextPropertyMap = prefetchTemplateAndContextPropertyMap.clone().get(hookId);
        if (!contextPropertyMap.hasKey(prefetchTemplateKey)) {
            return createCdsError(string `Unkown prefetch: ${prefetchTemplateKey}`, 400);
        }

        string contextProperty = contextPropertyMap.get(prefetchTemplateKey);

        string fhirServer = <string>cdsRequest.fhirServer;
        anydata contextValue = cdsRequest.clone().context.get(contextProperty);
        if contextValue is string {
            template = regexp:replace(re `\{\{context.${contextProperty}\}\}`, template, contextValue);
        } else {
            return cdsRequest.clone();
        }

        if (fhirServer.endsWith("/")) {
            fhirServer = fhirServer.substring(0, fhirServer.length() - 1);
        }

        if (!(template.startsWith("/"))) {
            template = string `/${template}`;
        }

        http:Client|http:ClientError fhirClient = new (fhirServer);
        if (fhirClient is http:ClientError) {
            return createCdsError(string `Can not make a HTTP client for the server url: ${fhirServer}`, 400, cause = fhirClient);
        }

        map<string|string[]> headers = {};
        if cdsRequest.fhirAuthorization !is () {
            headers["Authorization"] = string `Bearer ${(<FhirAuthorization>cdsRequest.fhirAuthorization).access_token}`;
        }
        http:Response|http:ClientError response = fhirClient->get(template, headers);
        if (response is http:ClientError) {
            return createCdsError(string `Something went wrong while fetching the FHIR resource: ${fhirServer}${template}`, 500, cause = response);
        }

        json|http:ClientError jsonPayload = response.getJsonPayload();
        if (jsonPayload is http:ClientError) {
            return createCdsError(string `FHIR data retrieved for : ${fhirServer}${template} is not JSON`, 412, cause = jsonPayload);
        }

        r4:DomainResource|error parsedResource = parser:parse(jsonPayload).ensureType(r4:DomainResource);
        if (parsedResource is error) {
            return createCdsError(string `Data retrieved for : ${fhirServer}${template} is not FHIR data`, 412, cause = parsedResource);
        }

        if (parsedResource is r4:OperationOutcome) {
            return createCdsError(string `FHIR data retrieved for : ${fhirServer}${template} is not valid`, 412);
        }

        r4:FHIRValidationError? validatedData = validator:validate(jsonPayload);
        if validatedData is r4:FHIRValidationError {
            return createCdsError(string `FHIR data retrieved for : ${fhirServer}${template} is not valid`, 412, cause = validatedData);
        }

        CdsRequest cdsRequestClone = cdsRequest.clone();
        cdsRequestClone.prefetch[prefetchTemplateKey] = parsedResource;
        return cdsRequestClone.clone();
    }

}

# Create a CDS type error.
#
# + message - Message to be added to the error.  
# + statusCode - Http status code.  
# + description - Human readable description about the issue.  
# + cause - (optional) original error.
# + return - CDS error record
public isolated function createCdsError(string message, int statusCode, string? description = (), error? cause = ()) returns CdsError {
    return error(message, message = message, code = statusCode, description = description, cause = cause);
}

# Create HTTP response from a CDS error record.
#
# + cdsError - CDS error record.
# + return - return HTTP response.
public isolated function cdsErrorToHttpResponse(CdsError cdsError) returns http:Response {
    http:Response response = new;

    response.statusCode = cdsError.detail().code;
    json responBody = {
        "message": cdsError.message()
    };

    string? description = cdsError.detail().description;
    if (description is string) {
        json|error mergeJson = responBody.mergeJson({"description": description});
        if mergeJson is json {
            responBody = mergeJson;
        }
    }

    response.setJsonPayload(responBody);
    return response;
}
